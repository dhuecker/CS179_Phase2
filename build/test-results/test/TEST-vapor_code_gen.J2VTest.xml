<?xml version="1.0" encoding="UTF-8"?>
<testsuite name="vapor_code_gen.J2VTest" tests="1" skipped="0" failures="1" errors="0" timestamp="2020-07-28T20:23:50" hostname="anthony-Aspire-TC-705" time="0.117">
  <properties/>
  <testcase name="binaryTree" classname="vapor_code_gen.J2VTest" time="0.117">
    <failure message="org.junit.ComparisonFailure: expected:&lt;[]&gt; but was:&lt;[const Tree_vtable&#10;  :Tree_GetHas_Right&#10;  :Tree_SetHas_Right&#10;  :Tree_Init&#10;  :Tree_RecPrint&#10;  :Tree_Compare&#10;  :Tree_Insert&#10;  :Tree_RemoveLeft&#10;  :Tree_Delete&#10;  :Tree_SetKey&#10;  :Tree_GetHas_Left&#10;  :Tree_GetKey&#10;  :Tree_SetHas_Left&#10;  :Tree_Search&#10;  :Tree_RemoveRight&#10;  :Tree_SetLeft&#10;  :Tree_Remove&#10;  :Tree_GetLeft&#10;  :Tree_Print&#10;  :Tree_GetRight&#10;  :Tree_SetRight&#10;&#10;const Tree&#10;  :Tree_vtable&#10;&#10;const BinaryTree_vtable&#10;  :Main&#10;&#10;const BinaryTree&#10;  :BinaryTree_vtable&#10;&#10;const BT_vtable&#10;  :BT_Start&#10;&#10;const BT&#10;  :BT_vtable&#10;&#10;func Main()&#10;  t.0 = HeapAllocZ(4)&#10;  [t.0] = :BT&#10;  t.1 = [t.0]&#10;  t.1 = [t.1]&#10;  t.1 = [t.1 + 0]&#10;  t.2 = call t.1(t.0)&#10;  PrintIntS(t.2)&#10;  ret&#10;&#10;func BT_Start(this)&#10;  t.3 = HeapAllocZ(28)&#10;  [t.3] = :Tree&#10;  root = t.3&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 8]&#10;  t.5 = call f(root 16 )&#10;  ntb = t.5&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 68]&#10;  t.7 = call f(root)&#10;  ntb = t.7&#10;  PrintIntS(100000000)&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 20]&#10;  t.9 = call f(root 8 )&#10;  ntb = t.9&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 68]&#10;  t.11 = call f(root)&#10;  ntb = t.11&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 20]&#10;  t.13 = call f(root 24 )&#10;  ntb = t.13&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 20]&#10;  t.15 = call f(root 4 )&#10;  ntb = t.15&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 20]&#10;  t.17 = call f(root 12 )&#10;  ntb = t.17&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 20]&#10;  t.19 = call f(root 20 )&#10;  ntb = t.19&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 20]&#10;  t.21 = call f(root 28 )&#10;  ntb = t.21&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 20]&#10;  t.23 = call f(root 14 )&#10;  ntb = t.23&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 68]&#10;  t.25 = call f(root)&#10;  ntb = t.25&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 48]&#10;  t.27 = call f(root 24 )&#10;  PrintIntS(t.27)&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 48]&#10;  t.29 = call f(root 12 )&#10;  PrintIntS(t.29)&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 48]&#10;  t.31 = call f(root 16 )&#10;  PrintIntS(t.31)&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 48]&#10;  t.33 = call f(root 50 )&#10;  PrintIntS(t.33)&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 48]&#10;  t.35 = call f(root 12 )&#10;  PrintIntS(t.35)&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 28]&#10;  t.37 = call f(root 12 )&#10;  ntb = t.37&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 68]&#10;  t.39 = call f(root)&#10;  ntb = t.39&#10;  vt = [root]&#10;  vt = [vt]&#10;  f = [vt + 48]&#10;  t.41 = call f(root 12 )&#10;  PrintIntS(t.41)&#10;  ret 0&#10;&#10;func Tree_Init(this v_key)&#10;  [this + 16] = v_key&#10;  [this + 12] = 0&#10;  [this + 8] = 0&#10;  ret 1&#10;&#10;func Tree_SetRight(this rn)&#10;  [this + 20] = rn&#10;  ret 1&#10;&#10;func Tree_SetLeft(this ln)&#10;  [this + 24] = ln&#10;  ret 1&#10;&#10;func Tree_GetRight(this)&#10;  t.42 = [this + 20]&#10;  ret t.42&#10;&#10;func Tree_GetLeft(this)&#10;  t.43 = [this + 24]&#10;  ret t.43&#10;&#10;func Tree_GetKey(this)&#10;  t.44 = [this + 16]&#10;  ret t.44&#10;&#10;func Tree_SetKey(this v_key)&#10;  [this + 16] = v_key&#10;  ret 1&#10;&#10;func Tree_GetHas_Right(this)&#10;  t.45 = [this + 8]&#10;  ret t.45&#10;&#10;func Tree_GetHas_Left(this)&#10;  t.46 = [this + 12]&#10;  ret t.46&#10;&#10;func Tree_SetHas_Left(this val)&#10;  [this + 12] = val&#10;  ret 1&#10;&#10;func Tree_SetHas_Right(this val)&#10;  [this + 8] = val&#10;  ret 1&#10;&#10;func Tree_Compare(this num1 num2)&#10;  ntb = 0&#10;  t.47 = Add(num2 1)&#10;  nti = t.47&#10;  t.48 = LtS(num1 num2)&#10;  if0 t.48 goto :l.0&#10;    ntb = 0&#10;    goto :l.1&#10;  l.0:&#10;    t.49 = LtS(num1 nti)&#10;    t.50 = 0&#10;    ok = Eq(0 t.49)&#10;    if ok goto :l.4&#10;    t.50 = 0&#10;    goto :l.5&#10;    l.4:&#10;    t.50 = 1&#10;    l.5:&#10;    if0 t.50 goto :l.2&#10;      ntb = 0&#10;      goto :l.3&#10;    l.2:&#10;      ntb = 1&#10;    l.3:&#10;  l.1:&#10;  ret ntb&#10;&#10;func Tree_Insert(this v_key)&#10;  t.51 = HeapAllocZ(28)&#10;  [t.51] = :Tree&#10;  new_node = t.51&#10;  vt = [new_node]&#10;  vt = [vt]&#10;  f = [vt + 8]&#10;  t.53 = call f(new_node v_key )&#10;  ntb = t.53&#10;  current_node = this&#10;  cont = 1&#10;  l.6:&#10;    if0 cont goto :l.7&#10;    vt = [current_node]&#10;    vt = [vt]&#10;    f = [vt + 40]&#10;    t.55 = call f(current_node)&#10;    key_aux = t.55&#10;    t.56 = LtS(v_key key_aux)&#10;    if0 t.56 goto :l.8&#10;      vt = [current_node]&#10;      vt = [vt]&#10;      f = [vt + 36]&#10;      t.58 = call f(current_node)&#10;      if0 t.58 goto :l.10&#10;        vt = [current_node]&#10;        vt = [vt]&#10;        f = [vt + 64]&#10;        t.60 = call f(current_node)&#10;        current_node = t.60&#10;        goto :l.11&#10;      l.10:&#10;        cont = 0&#10;        vt = [current_node]&#10;        vt = [vt]&#10;        f = [vt + 44]&#10;        t.62 = call f(current_node 1 )&#10;        ntb = t.62&#10;        vt = [current_node]&#10;        vt = [vt]&#10;        f = [vt + 56]&#10;        t.64 = call f(current_node new_node )&#10;        ntb = t.64&#10;      l.11:&#10;      goto :l.9&#10;    l.8:&#10;      vt = [current_node]&#10;      vt = [vt]&#10;      f = [vt + 0]&#10;      t.66 = call f(current_node)&#10;      if0 t.66 goto :l.12&#10;        vt = [current_node]&#10;        vt = [vt]&#10;        f = [vt + 72]&#10;        t.68 = call f(current_node)&#10;        current_node = t.68&#10;        goto :l.13&#10;      l.12:&#10;        cont = 0&#10;        vt = [current_node]&#10;        vt = [vt]&#10;        f = [vt + 4]&#10;        t.70 = call f(current_node 1 )&#10;        ntb = t.70&#10;        vt = [current_node]&#10;        vt = [vt]&#10;        f = [vt + 76]&#10;        t.72 = call f(current_node new_node )&#10;        ntb = t.72&#10;      l.13:&#10;    l.9:&#10;  goto :l.6&#10;  l.7:&#10;  ret 1&#10;&#10;func Tree_Delete(this v_key)&#10;  current_node = this&#10;  parent_node = this&#10;  cont = 1&#10;  found = 0&#10;  is_root = 1&#10;  l.14:&#10;    if0 cont goto :l.15&#10;    vt = [current_node]&#10;    vt = [vt]&#10;    f = [vt + 40]&#10;    t.74 = call f(current_node)&#10;    key_aux = t.74&#10;    t.75 = LtS(v_key key_aux)&#10;    if0 t.75 goto :l.16&#10;      vt = [current_node]&#10;      vt = [vt]&#10;      f = [vt + 36]&#10;      t.77 = call f(current_node)&#10;      if0 t.77 goto :l.18&#10;        parent_node = current_node&#10;        vt = [current_node]&#10;        vt = [vt]&#10;        f = [vt + 64]&#10;        t.79 = call f(current_node)&#10;        current_node = t.79&#10;        goto :l.19&#10;      l.18:&#10;        cont = 0&#10;      l.19:&#10;      goto :l.17&#10;    l.16:&#10;      t.80 = LtS(key_aux v_key)&#10;      if0 t.80 goto :l.20&#10;        vt = [current_node]&#10;        vt = [vt]&#10;        f = [vt + 0]&#10;        t.82 = call f(current_node)&#10;        if0 t.82 goto :l.22&#10;          parent_node = current_node&#10;          vt = [current_node]&#10;          vt = [vt]&#10;          f = [vt + 72]&#10;          t.84 = call f(current_node)&#10;          current_node = t.84&#10;          goto :l.23&#10;        l.22:&#10;          cont = 0&#10;        l.23:&#10;        goto :l.21&#10;      l.20:&#10;        if0 is_root goto :l.24&#10;          vt = [current_node]&#10;          vt = [vt]&#10;          f = [vt + 0]&#10;          t.86 = call f(current_node)&#10;          t.87 = 0&#10;          ok = Eq(0 t.86)&#10;          if ok goto :l.28&#10;          t.87 = 0&#10;          goto :l.29&#10;          l.28:&#10;          t.87 = 1&#10;          l.29:&#10;          vt = [current_node]&#10;          vt = [vt]&#10;          f = [vt + 36]&#10;          t.89 = call f(current_node)&#10;          t.90 = 0&#10;          ok = Eq(0 t.89)&#10;          if ok goto :l.30&#10;          t.90 = 0&#10;          goto :l.31&#10;          l.30:&#10;          t.90 = 1&#10;          l.31:&#10;          t.91 = Eq(1 t.87)&#10;          t.92 = Eq(1 t.90)&#10;          t.93 = Eq(t.91 t.92)&#10;          if0 t.93 goto :l.26&#10;            ntb = 1&#10;            goto :l.27&#10;          l.26:&#10;            t.96 = [this]&#10;            t.96 = [t.96]&#10;            t.96 = [t.96 + 60]&#10;            t.95 = call t.96(this parent_node current_node )&#10;            ntb = t.95&#10;          l.27:&#10;          goto :l.25&#10;        l.24:&#10;          t.99 = [this]&#10;          t.99 = [t.99]&#10;          t.99 = [t.99 + 60]&#10;          t.98 = call t.99(this parent_node current_node )&#10;          ntb = t.98&#10;        l.25:&#10;        found = 1&#10;        cont = 0&#10;      l.21:&#10;    l.17:&#10;    is_root = 0&#10;  goto :l.14&#10;  l.15:&#10;  ret found&#10;&#10;func Tree_Remove(this p_node c_node)&#10;  vt = [c_node]&#10;  vt = [vt]&#10;  f = [vt + 36]&#10;  t.101 = call f(c_node)&#10;  if0 t.101 goto :l.32&#10;    t.104 = [this]&#10;    t.104 = [t.104]&#10;    t.104 = [t.104 + 24]&#10;    t.103 = call t.104(this p_node c_node )&#10;    ntb = t.103&#10;    goto :l.33&#10;  l.32:&#10;    vt = [c_node]&#10;    vt = [vt]&#10;    f = [vt + 0]&#10;    t.106 = call f(c_node)&#10;    if0 t.106 goto :l.34&#10;      t.109 = [this]&#10;      t.109 = [t.109]&#10;      t.109 = [t.109 + 52]&#10;      t.108 = call t.109(this p_node c_node )&#10;      ntb = t.108&#10;      goto :l.35&#10;    l.34:&#10;      vt = [c_node]&#10;      vt = [vt]&#10;      f = [vt + 40]&#10;      t.111 = call f(c_node)&#10;      auxkey1 = t.111&#10;      vt = [p_node]&#10;      vt = [vt]&#10;      f = [vt + 64]&#10;      t.113 = call f(p_node)&#10;      vt = [t.113]&#10;      vt = [vt]&#10;      f = [vt + 40]&#10;      t.115 = call f(t.113)&#10;      auxkey2 = t.115&#10;      t.118 = [this]&#10;      t.118 = [t.118]&#10;      t.118 = [t.118 + 16]&#10;      t.117 = call t.118(this auxkey1 auxkey2 )&#10;      if0 t.117 goto :l.36&#10;        t.121 = [this + 4]&#10;        vt = [p_node]&#10;        vt = [vt]&#10;        f = [vt + 56]&#10;        t.120 = call f(p_node t.121 )&#10;        ntb = t.120&#10;        vt = [p_node]&#10;        vt = [vt]&#10;        f = [vt + 44]&#10;        t.123 = call f(p_node 0 )&#10;        ntb = t.123&#10;        goto :l.37&#10;      l.36:&#10;        t.126 = [this + 4]&#10;        vt = [p_node]&#10;        vt = [vt]&#10;        f = [vt + 76]&#10;        t.125 = call f(p_node t.126 )&#10;        ntb = t.125&#10;        vt = [p_node]&#10;        vt = [vt]&#10;        f = [vt + 4]&#10;        t.128 = call f(p_node 0 )&#10;        ntb = t.128&#10;      l.37:&#10;    l.35:&#10;  l.33:&#10;  ret 1&#10;&#10;func Tree_RemoveRight(this p_node c_node)&#10;  l.38:&#10;    vt = [c_node]&#10;    vt = [vt]&#10;    f = [vt + 0]&#10;    t.130 = call f(c_node)&#10;    if0 t.130 goto :l.39&#10;    vt = [c_node]&#10;    vt = [vt]&#10;    f = [vt + 72]&#10;    t.132 = call f(c_node)&#10;    vt = [t.132]&#10;    vt = [vt]&#10;    f = [vt + 40]&#10;    t.134 = call f(t.132)&#10;    vt = [c_node]&#10;    vt = [vt]&#10;    f = [vt + 32]&#10;    t.136 = call f(c_node t.134 )&#10;    ntb = t.136&#10;    p_node = c_node&#10;    vt = [c_node]&#10;    vt = [vt]&#10;    f = [vt + 72]&#10;    t.138 = call f(c_node)&#10;    c_node = t.138&#10;  goto :l.38&#10;  l.39:&#10;  t.141 = [this + 4]&#10;  vt = [p_node]&#10;  vt = [vt]&#10;  f = [vt + 76]&#10;  t.140 = call f(p_node t.141 )&#10;  ntb = t.140&#10;  vt = [p_node]&#10;  vt = [vt]&#10;  f = [vt + 4]&#10;  t.143 = call f(p_node 0 )&#10;  ntb = t.143&#10;  ret 1&#10;&#10;func Tree_RemoveLeft(this p_node c_node)&#10;  l.40:&#10;    vt = [c_node]&#10;    vt = [vt]&#10;    f = [vt + 36]&#10;    t.145 = call f(c_node)&#10;    if0 t.145 goto :l.41&#10;    vt = [c_node]&#10;    vt = [vt]&#10;    f = [vt + 64]&#10;    t.147 = call f(c_node)&#10;    vt = [t.147]&#10;    vt = [vt]&#10;    f = [vt + 40]&#10;    t.149 = call f(t.147)&#10;    vt = [c_node]&#10;    vt = [vt]&#10;    f = [vt + 32]&#10;    t.151 = call f(c_node t.149 )&#10;    ntb = t.151&#10;    p_node = c_node&#10;    vt = [c_node]&#10;    vt = [vt]&#10;    f = [vt + 64]&#10;    t.153 = call f(c_node)&#10;    c_node = t.153&#10;  goto :l.40&#10;  l.41:&#10;  t.156 = [this + 4]&#10;  vt = [p_node]&#10;  vt = [vt]&#10;  f = [vt + 56]&#10;  t.155 = call f(p_node t.156 )&#10;  ntb = t.155&#10;  vt = [p_node]&#10;  vt = [vt]&#10;  f = [vt + 44]&#10;  t.158 = call f(p_node 0 )&#10;  ntb = t.158&#10;  ret 1&#10;&#10;func Tree_Search(this v_key)&#10;  current_node = this&#10;  cont = 1&#10;  ifound = 0&#10;  l.42:&#10;    if0 cont goto :l.43&#10;    vt = [current_node]&#10;    vt = [vt]&#10;    f = [vt + 40]&#10;    t.160 = call f(current_node)&#10;    key_aux = t.160&#10;    t.161 = LtS(v_key key_aux)&#10;    if0 t.161 goto :l.44&#10;      vt = [current_node]&#10;      vt = [vt]&#10;      f = [vt + 36]&#10;      t.163 = call f(current_node)&#10;      if0 t.163 goto :l.46&#10;        vt = [current_node]&#10;        vt = [vt]&#10;        f = [vt + 64]&#10;        t.165 = call f(current_node)&#10;        current_node = t.165&#10;        goto :l.47&#10;      l.46:&#10;        cont = 0&#10;      l.47:&#10;      goto :l.45&#10;    l.44:&#10;      t.166 = LtS(key_aux v_key)&#10;      if0 t.166 goto :l.48&#10;        vt = [current_node]&#10;        vt = [vt]&#10;        f = [vt + 0]&#10;        t.168 = call f(current_node)&#10;        if0 t.168 goto :l.50&#10;          vt = [current_node]&#10;          vt = [vt]&#10;          f = [vt + 72]&#10;          t.170 = call f(current_node)&#10;          current_node = t.170&#10;          goto :l.51&#10;        l.50:&#10;          cont = 0&#10;        l.51:&#10;        goto :l.49&#10;      l.48:&#10;        ifound = 1&#10;        cont = 0&#10;      l.49:&#10;    l.45:&#10;  goto :l.42&#10;  l.43:&#10;  ret ifound&#10;&#10;func Tree_Print(this)&#10;  current_node = this&#10;  t.173 = [this]&#10;  t.173 = [t.173]&#10;  t.173 = [t.173 + 12]&#10;  t.172 = call t.173(this current_node )&#10;  ntb = t.172&#10;  ret 1&#10;&#10;func Tree_RecPrint(this node)&#10;  vt = [node]&#10;  vt = [vt]&#10;  f = [vt + 36]&#10;  t.175 = call f(node)&#10;  if0 t.175 goto :l.52&#10;    vt = [node]&#10;    vt = [vt]&#10;    f = [vt + 64]&#10;    t.177 = call f(node)&#10;    t.180 = [this]&#10;    t.180 = [t.180]&#10;    t.180 = [t.180 + 12]&#10;    t.179 = call t.180(this t.177 )&#10;    ntb = t.179&#10;    goto :l.53&#10;  l.52:&#10;    ntb = 1&#10;  l.53:&#10;  vt = [node]&#10;  vt = [vt]&#10;  f = [vt + 40]&#10;  t.182 = call f(node)&#10;  PrintIntS(t.182)&#10;  vt = [node]&#10;  vt = [vt]&#10;  f = [vt + 0]&#10;  t.184 = call f(node)&#10;  if0 t.184 goto :l.54&#10;    vt = [node]&#10;    vt = [vt]&#10;    f = [vt + 72]&#10;    t.186 = call f(node)&#10;    t.189 = [this]&#10;    t.189 = [t.189]&#10;    t.189 = [t.189 + 12]&#10;    t.188 = call t.189(this t.186 )&#10;    ntb = t.188&#10;    goto :l.55&#10;  l.54:&#10;    ntb = 1&#10;  l.55:&#10;  ret 1&#10;&#10;&#10;]&gt;" type="org.junit.ComparisonFailure">org.junit.ComparisonFailure: expected:&lt;[]&gt; but was:&lt;[const Tree_vtable
  :Tree_GetHas_Right
  :Tree_SetHas_Right
  :Tree_Init
  :Tree_RecPrint
  :Tree_Compare
  :Tree_Insert
  :Tree_RemoveLeft
  :Tree_Delete
  :Tree_SetKey
  :Tree_GetHas_Left
  :Tree_GetKey
  :Tree_SetHas_Left
  :Tree_Search
  :Tree_RemoveRight
  :Tree_SetLeft
  :Tree_Remove
  :Tree_GetLeft
  :Tree_Print
  :Tree_GetRight
  :Tree_SetRight

const Tree
  :Tree_vtable

const BinaryTree_vtable
  :Main

const BinaryTree
  :BinaryTree_vtable

const BT_vtable
  :BT_Start

const BT
  :BT_vtable

func Main()
  t.0 = HeapAllocZ(4)
  [t.0] = :BT
  t.1 = [t.0]
  t.1 = [t.1]
  t.1 = [t.1 + 0]
  t.2 = call t.1(t.0)
  PrintIntS(t.2)
  ret

func BT_Start(this)
  t.3 = HeapAllocZ(28)
  [t.3] = :Tree
  root = t.3
  vt = [root]
  vt = [vt]
  f = [vt + 8]
  t.5 = call f(root 16 )
  ntb = t.5
  vt = [root]
  vt = [vt]
  f = [vt + 68]
  t.7 = call f(root)
  ntb = t.7
  PrintIntS(100000000)
  vt = [root]
  vt = [vt]
  f = [vt + 20]
  t.9 = call f(root 8 )
  ntb = t.9
  vt = [root]
  vt = [vt]
  f = [vt + 68]
  t.11 = call f(root)
  ntb = t.11
  vt = [root]
  vt = [vt]
  f = [vt + 20]
  t.13 = call f(root 24 )
  ntb = t.13
  vt = [root]
  vt = [vt]
  f = [vt + 20]
  t.15 = call f(root 4 )
  ntb = t.15
  vt = [root]
  vt = [vt]
  f = [vt + 20]
  t.17 = call f(root 12 )
  ntb = t.17
  vt = [root]
  vt = [vt]
  f = [vt + 20]
  t.19 = call f(root 20 )
  ntb = t.19
  vt = [root]
  vt = [vt]
  f = [vt + 20]
  t.21 = call f(root 28 )
  ntb = t.21
  vt = [root]
  vt = [vt]
  f = [vt + 20]
  t.23 = call f(root 14 )
  ntb = t.23
  vt = [root]
  vt = [vt]
  f = [vt + 68]
  t.25 = call f(root)
  ntb = t.25
  vt = [root]
  vt = [vt]
  f = [vt + 48]
  t.27 = call f(root 24 )
  PrintIntS(t.27)
  vt = [root]
  vt = [vt]
  f = [vt + 48]
  t.29 = call f(root 12 )
  PrintIntS(t.29)
  vt = [root]
  vt = [vt]
  f = [vt + 48]
  t.31 = call f(root 16 )
  PrintIntS(t.31)
  vt = [root]
  vt = [vt]
  f = [vt + 48]
  t.33 = call f(root 50 )
  PrintIntS(t.33)
  vt = [root]
  vt = [vt]
  f = [vt + 48]
  t.35 = call f(root 12 )
  PrintIntS(t.35)
  vt = [root]
  vt = [vt]
  f = [vt + 28]
  t.37 = call f(root 12 )
  ntb = t.37
  vt = [root]
  vt = [vt]
  f = [vt + 68]
  t.39 = call f(root)
  ntb = t.39
  vt = [root]
  vt = [vt]
  f = [vt + 48]
  t.41 = call f(root 12 )
  PrintIntS(t.41)
  ret 0

func Tree_Init(this v_key)
  [this + 16] = v_key
  [this + 12] = 0
  [this + 8] = 0
  ret 1

func Tree_SetRight(this rn)
  [this + 20] = rn
  ret 1

func Tree_SetLeft(this ln)
  [this + 24] = ln
  ret 1

func Tree_GetRight(this)
  t.42 = [this + 20]
  ret t.42

func Tree_GetLeft(this)
  t.43 = [this + 24]
  ret t.43

func Tree_GetKey(this)
  t.44 = [this + 16]
  ret t.44

func Tree_SetKey(this v_key)
  [this + 16] = v_key
  ret 1

func Tree_GetHas_Right(this)
  t.45 = [this + 8]
  ret t.45

func Tree_GetHas_Left(this)
  t.46 = [this + 12]
  ret t.46

func Tree_SetHas_Left(this val)
  [this + 12] = val
  ret 1

func Tree_SetHas_Right(this val)
  [this + 8] = val
  ret 1

func Tree_Compare(this num1 num2)
  ntb = 0
  t.47 = Add(num2 1)
  nti = t.47
  t.48 = LtS(num1 num2)
  if0 t.48 goto :l.0
    ntb = 0
    goto :l.1
  l.0:
    t.49 = LtS(num1 nti)
    t.50 = 0
    ok = Eq(0 t.49)
    if ok goto :l.4
    t.50 = 0
    goto :l.5
    l.4:
    t.50 = 1
    l.5:
    if0 t.50 goto :l.2
      ntb = 0
      goto :l.3
    l.2:
      ntb = 1
    l.3:
  l.1:
  ret ntb

func Tree_Insert(this v_key)
  t.51 = HeapAllocZ(28)
  [t.51] = :Tree
  new_node = t.51
  vt = [new_node]
  vt = [vt]
  f = [vt + 8]
  t.53 = call f(new_node v_key )
  ntb = t.53
  current_node = this
  cont = 1
  l.6:
    if0 cont goto :l.7
    vt = [current_node]
    vt = [vt]
    f = [vt + 40]
    t.55 = call f(current_node)
    key_aux = t.55
    t.56 = LtS(v_key key_aux)
    if0 t.56 goto :l.8
      vt = [current_node]
      vt = [vt]
      f = [vt + 36]
      t.58 = call f(current_node)
      if0 t.58 goto :l.10
        vt = [current_node]
        vt = [vt]
        f = [vt + 64]
        t.60 = call f(current_node)
        current_node = t.60
        goto :l.11
      l.10:
        cont = 0
        vt = [current_node]
        vt = [vt]
        f = [vt + 44]
        t.62 = call f(current_node 1 )
        ntb = t.62
        vt = [current_node]
        vt = [vt]
        f = [vt + 56]
        t.64 = call f(current_node new_node )
        ntb = t.64
      l.11:
      goto :l.9
    l.8:
      vt = [current_node]
      vt = [vt]
      f = [vt + 0]
      t.66 = call f(current_node)
      if0 t.66 goto :l.12
        vt = [current_node]
        vt = [vt]
        f = [vt + 72]
        t.68 = call f(current_node)
        current_node = t.68
        goto :l.13
      l.12:
        cont = 0
        vt = [current_node]
        vt = [vt]
        f = [vt + 4]
        t.70 = call f(current_node 1 )
        ntb = t.70
        vt = [current_node]
        vt = [vt]
        f = [vt + 76]
        t.72 = call f(current_node new_node )
        ntb = t.72
      l.13:
    l.9:
  goto :l.6
  l.7:
  ret 1

func Tree_Delete(this v_key)
  current_node = this
  parent_node = this
  cont = 1
  found = 0
  is_root = 1
  l.14:
    if0 cont goto :l.15
    vt = [current_node]
    vt = [vt]
    f = [vt + 40]
    t.74 = call f(current_node)
    key_aux = t.74
    t.75 = LtS(v_key key_aux)
    if0 t.75 goto :l.16
      vt = [current_node]
      vt = [vt]
      f = [vt + 36]
      t.77 = call f(current_node)
      if0 t.77 goto :l.18
        parent_node = current_node
        vt = [current_node]
        vt = [vt]
        f = [vt + 64]
        t.79 = call f(current_node)
        current_node = t.79
        goto :l.19
      l.18:
        cont = 0
      l.19:
      goto :l.17
    l.16:
      t.80 = LtS(key_aux v_key)
      if0 t.80 goto :l.20
        vt = [current_node]
        vt = [vt]
        f = [vt + 0]
        t.82 = call f(current_node)
        if0 t.82 goto :l.22
          parent_node = current_node
          vt = [current_node]
          vt = [vt]
          f = [vt + 72]
          t.84 = call f(current_node)
          current_node = t.84
          goto :l.23
        l.22:
          cont = 0
        l.23:
        goto :l.21
      l.20:
        if0 is_root goto :l.24
          vt = [current_node]
          vt = [vt]
          f = [vt + 0]
          t.86 = call f(current_node)
          t.87 = 0
          ok = Eq(0 t.86)
          if ok goto :l.28
          t.87 = 0
          goto :l.29
          l.28:
          t.87 = 1
          l.29:
          vt = [current_node]
          vt = [vt]
          f = [vt + 36]
          t.89 = call f(current_node)
          t.90 = 0
          ok = Eq(0 t.89)
          if ok goto :l.30
          t.90 = 0
          goto :l.31
          l.30:
          t.90 = 1
          l.31:
          t.91 = Eq(1 t.87)
          t.92 = Eq(1 t.90)
          t.93 = Eq(t.91 t.92)
          if0 t.93 goto :l.26
            ntb = 1
            goto :l.27
          l.26:
            t.96 = [this]
            t.96 = [t.96]
            t.96 = [t.96 + 60]
            t.95 = call t.96(this parent_node current_node )
            ntb = t.95
          l.27:
          goto :l.25
        l.24:
          t.99 = [this]
          t.99 = [t.99]
          t.99 = [t.99 + 60]
          t.98 = call t.99(this parent_node current_node )
          ntb = t.98
        l.25:
        found = 1
        cont = 0
      l.21:
    l.17:
    is_root = 0
  goto :l.14
  l.15:
  ret found

func Tree_Remove(this p_node c_node)
  vt = [c_node]
  vt = [vt]
  f = [vt + 36]
  t.101 = call f(c_node)
  if0 t.101 goto :l.32
    t.104 = [this]
    t.104 = [t.104]
    t.104 = [t.104 + 24]
    t.103 = call t.104(this p_node c_node )
    ntb = t.103
    goto :l.33
  l.32:
    vt = [c_node]
    vt = [vt]
    f = [vt + 0]
    t.106 = call f(c_node)
    if0 t.106 goto :l.34
      t.109 = [this]
      t.109 = [t.109]
      t.109 = [t.109 + 52]
      t.108 = call t.109(this p_node c_node )
      ntb = t.108
      goto :l.35
    l.34:
      vt = [c_node]
      vt = [vt]
      f = [vt + 40]
      t.111 = call f(c_node)
      auxkey1 = t.111
      vt = [p_node]
      vt = [vt]
      f = [vt + 64]
      t.113 = call f(p_node)
      vt = [t.113]
      vt = [vt]
      f = [vt + 40]
      t.115 = call f(t.113)
      auxkey2 = t.115
      t.118 = [this]
      t.118 = [t.118]
      t.118 = [t.118 + 16]
      t.117 = call t.118(this auxkey1 auxkey2 )
      if0 t.117 goto :l.36
        t.121 = [this + 4]
        vt = [p_node]
        vt = [vt]
        f = [vt + 56]
        t.120 = call f(p_node t.121 )
        ntb = t.120
        vt = [p_node]
        vt = [vt]
        f = [vt + 44]
        t.123 = call f(p_node 0 )
        ntb = t.123
        goto :l.37
      l.36:
        t.126 = [this + 4]
        vt = [p_node]
        vt = [vt]
        f = [vt + 76]
        t.125 = call f(p_node t.126 )
        ntb = t.125
        vt = [p_node]
        vt = [vt]
        f = [vt + 4]
        t.128 = call f(p_node 0 )
        ntb = t.128
      l.37:
    l.35:
  l.33:
  ret 1

func Tree_RemoveRight(this p_node c_node)
  l.38:
    vt = [c_node]
    vt = [vt]
    f = [vt + 0]
    t.130 = call f(c_node)
    if0 t.130 goto :l.39
    vt = [c_node]
    vt = [vt]
    f = [vt + 72]
    t.132 = call f(c_node)
    vt = [t.132]
    vt = [vt]
    f = [vt + 40]
    t.134 = call f(t.132)
    vt = [c_node]
    vt = [vt]
    f = [vt + 32]
    t.136 = call f(c_node t.134 )
    ntb = t.136
    p_node = c_node
    vt = [c_node]
    vt = [vt]
    f = [vt + 72]
    t.138 = call f(c_node)
    c_node = t.138
  goto :l.38
  l.39:
  t.141 = [this + 4]
  vt = [p_node]
  vt = [vt]
  f = [vt + 76]
  t.140 = call f(p_node t.141 )
  ntb = t.140
  vt = [p_node]
  vt = [vt]
  f = [vt + 4]
  t.143 = call f(p_node 0 )
  ntb = t.143
  ret 1

func Tree_RemoveLeft(this p_node c_node)
  l.40:
    vt = [c_node]
    vt = [vt]
    f = [vt + 36]
    t.145 = call f(c_node)
    if0 t.145 goto :l.41
    vt = [c_node]
    vt = [vt]
    f = [vt + 64]
    t.147 = call f(c_node)
    vt = [t.147]
    vt = [vt]
    f = [vt + 40]
    t.149 = call f(t.147)
    vt = [c_node]
    vt = [vt]
    f = [vt + 32]
    t.151 = call f(c_node t.149 )
    ntb = t.151
    p_node = c_node
    vt = [c_node]
    vt = [vt]
    f = [vt + 64]
    t.153 = call f(c_node)
    c_node = t.153
  goto :l.40
  l.41:
  t.156 = [this + 4]
  vt = [p_node]
  vt = [vt]
  f = [vt + 56]
  t.155 = call f(p_node t.156 )
  ntb = t.155
  vt = [p_node]
  vt = [vt]
  f = [vt + 44]
  t.158 = call f(p_node 0 )
  ntb = t.158
  ret 1

func Tree_Search(this v_key)
  current_node = this
  cont = 1
  ifound = 0
  l.42:
    if0 cont goto :l.43
    vt = [current_node]
    vt = [vt]
    f = [vt + 40]
    t.160 = call f(current_node)
    key_aux = t.160
    t.161 = LtS(v_key key_aux)
    if0 t.161 goto :l.44
      vt = [current_node]
      vt = [vt]
      f = [vt + 36]
      t.163 = call f(current_node)
      if0 t.163 goto :l.46
        vt = [current_node]
        vt = [vt]
        f = [vt + 64]
        t.165 = call f(current_node)
        current_node = t.165
        goto :l.47
      l.46:
        cont = 0
      l.47:
      goto :l.45
    l.44:
      t.166 = LtS(key_aux v_key)
      if0 t.166 goto :l.48
        vt = [current_node]
        vt = [vt]
        f = [vt + 0]
        t.168 = call f(current_node)
        if0 t.168 goto :l.50
          vt = [current_node]
          vt = [vt]
          f = [vt + 72]
          t.170 = call f(current_node)
          current_node = t.170
          goto :l.51
        l.50:
          cont = 0
        l.51:
        goto :l.49
      l.48:
        ifound = 1
        cont = 0
      l.49:
    l.45:
  goto :l.42
  l.43:
  ret ifound

func Tree_Print(this)
  current_node = this
  t.173 = [this]
  t.173 = [t.173]
  t.173 = [t.173 + 12]
  t.172 = call t.173(this current_node )
  ntb = t.172
  ret 1

func Tree_RecPrint(this node)
  vt = [node]
  vt = [vt]
  f = [vt + 36]
  t.175 = call f(node)
  if0 t.175 goto :l.52
    vt = [node]
    vt = [vt]
    f = [vt + 64]
    t.177 = call f(node)
    t.180 = [this]
    t.180 = [t.180]
    t.180 = [t.180 + 12]
    t.179 = call t.180(this t.177 )
    ntb = t.179
    goto :l.53
  l.52:
    ntb = 1
  l.53:
  vt = [node]
  vt = [vt]
  f = [vt + 40]
  t.182 = call f(node)
  PrintIntS(t.182)
  vt = [node]
  vt = [vt]
  f = [vt + 0]
  t.184 = call f(node)
  if0 t.184 goto :l.54
    vt = [node]
    vt = [vt]
    f = [vt + 72]
    t.186 = call f(node)
    t.189 = [this]
    t.189 = [t.189]
    t.189 = [t.189 + 12]
    t.188 = call t.189(this t.186 )
    ntb = t.188
    goto :l.55
  l.54:
    ntb = 1
  l.55:
  ret 1


]&gt;
	at org.junit.Assert.assertEquals(Assert.java:115)
	at org.junit.Assert.assertEquals(Assert.java:144)
	at vapor_code_gen.J2VTest.binaryTree(J2VTest.java:48)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.runTestClass(JUnitTestClassExecutor.java:110)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:58)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:38)
	at org.gradle.api.internal.tasks.testing.junit.AbstractJUnitTestClassProcessor.processTestClass(AbstractJUnitTestClassProcessor.java:62)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94)
	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:118)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:412)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)
	at java.base/java.lang.Thread.run(Thread.java:844)
</failure>
  </testcase>
  <system-out><![CDATA[]]></system-out>
  <system-err><![CDATA[]]></system-err>
</testsuite>
