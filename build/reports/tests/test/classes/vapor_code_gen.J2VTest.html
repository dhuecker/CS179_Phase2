<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=edge"/>
<title>Test results - Class vapor_code_gen.J2VTest</title>
<link href="../css/base-style.css" rel="stylesheet" type="text/css"/>
<link href="../css/style.css" rel="stylesheet" type="text/css"/>
<script src="../js/report.js" type="text/javascript"></script>
</head>
<body>
<div id="content">
<h1>Class vapor_code_gen.J2VTest</h1>
<div class="breadcrumbs">
<a href="../index.html">all</a> &gt; 
<a href="../packages/vapor_code_gen.html">vapor_code_gen</a> &gt; J2VTest</div>
<div id="summary">
<table>
<tr>
<td>
<div class="summaryGroup">
<table>
<tr>
<td>
<div class="infoBox" id="tests">
<div class="counter">1</div>
<p>tests</p>
</div>
</td>
<td>
<div class="infoBox" id="failures">
<div class="counter">1</div>
<p>failures</p>
</div>
</td>
<td>
<div class="infoBox" id="ignored">
<div class="counter">0</div>
<p>ignored</p>
</div>
</td>
<td>
<div class="infoBox" id="duration">
<div class="counter">0.117s</div>
<p>duration</p>
</div>
</td>
</tr>
</table>
</div>
</td>
<td>
<div class="infoBox failures" id="successRate">
<div class="percent">0%</div>
<p>successful</p>
</div>
</td>
</tr>
</table>
</div>
<div id="tabs">
<ul class="tabLinks">
<li>
<a href="#tab0">Failed tests</a>
</li>
<li>
<a href="#tab1">Tests</a>
</li>
</ul>
<div id="tab0" class="tab">
<h2>Failed tests</h2>
<div class="test">
<a name="binaryTree"></a>
<h3 class="failures">binaryTree</h3>
<span class="code">
<pre>org.junit.ComparisonFailure: expected:&lt;[]&gt; but was:&lt;[const Tree_vtable
  :Tree_GetHas_Right
  :Tree_SetHas_Right
  :Tree_Init
  :Tree_RecPrint
  :Tree_Compare
  :Tree_Insert
  :Tree_RemoveLeft
  :Tree_Delete
  :Tree_SetKey
  :Tree_GetHas_Left
  :Tree_GetKey
  :Tree_SetHas_Left
  :Tree_Search
  :Tree_RemoveRight
  :Tree_SetLeft
  :Tree_Remove
  :Tree_GetLeft
  :Tree_Print
  :Tree_GetRight
  :Tree_SetRight

const Tree
  :Tree_vtable

const BinaryTree_vtable
  :Main

const BinaryTree
  :BinaryTree_vtable

const BT_vtable
  :BT_Start

const BT
  :BT_vtable

func Main()
  t.0 = HeapAllocZ(4)
  [t.0] = :BT
  t.1 = [t.0]
  t.1 = [t.1]
  t.1 = [t.1 + 0]
  t.2 = call t.1(t.0)
  PrintIntS(t.2)
  ret

func BT_Start(this)
  t.3 = HeapAllocZ(28)
  [t.3] = :Tree
  root = t.3
  vt = [root]
  vt = [vt]
  f = [vt + 8]
  t.5 = call f(root 16 )
  ntb = t.5
  vt = [root]
  vt = [vt]
  f = [vt + 68]
  t.7 = call f(root)
  ntb = t.7
  PrintIntS(100000000)
  vt = [root]
  vt = [vt]
  f = [vt + 20]
  t.9 = call f(root 8 )
  ntb = t.9
  vt = [root]
  vt = [vt]
  f = [vt + 68]
  t.11 = call f(root)
  ntb = t.11
  vt = [root]
  vt = [vt]
  f = [vt + 20]
  t.13 = call f(root 24 )
  ntb = t.13
  vt = [root]
  vt = [vt]
  f = [vt + 20]
  t.15 = call f(root 4 )
  ntb = t.15
  vt = [root]
  vt = [vt]
  f = [vt + 20]
  t.17 = call f(root 12 )
  ntb = t.17
  vt = [root]
  vt = [vt]
  f = [vt + 20]
  t.19 = call f(root 20 )
  ntb = t.19
  vt = [root]
  vt = [vt]
  f = [vt + 20]
  t.21 = call f(root 28 )
  ntb = t.21
  vt = [root]
  vt = [vt]
  f = [vt + 20]
  t.23 = call f(root 14 )
  ntb = t.23
  vt = [root]
  vt = [vt]
  f = [vt + 68]
  t.25 = call f(root)
  ntb = t.25
  vt = [root]
  vt = [vt]
  f = [vt + 48]
  t.27 = call f(root 24 )
  PrintIntS(t.27)
  vt = [root]
  vt = [vt]
  f = [vt + 48]
  t.29 = call f(root 12 )
  PrintIntS(t.29)
  vt = [root]
  vt = [vt]
  f = [vt + 48]
  t.31 = call f(root 16 )
  PrintIntS(t.31)
  vt = [root]
  vt = [vt]
  f = [vt + 48]
  t.33 = call f(root 50 )
  PrintIntS(t.33)
  vt = [root]
  vt = [vt]
  f = [vt + 48]
  t.35 = call f(root 12 )
  PrintIntS(t.35)
  vt = [root]
  vt = [vt]
  f = [vt + 28]
  t.37 = call f(root 12 )
  ntb = t.37
  vt = [root]
  vt = [vt]
  f = [vt + 68]
  t.39 = call f(root)
  ntb = t.39
  vt = [root]
  vt = [vt]
  f = [vt + 48]
  t.41 = call f(root 12 )
  PrintIntS(t.41)
  ret 0

func Tree_Init(this v_key)
  [this + 16] = v_key
  [this + 12] = 0
  [this + 8] = 0
  ret 1

func Tree_SetRight(this rn)
  [this + 20] = rn
  ret 1

func Tree_SetLeft(this ln)
  [this + 24] = ln
  ret 1

func Tree_GetRight(this)
  t.42 = [this + 20]
  ret t.42

func Tree_GetLeft(this)
  t.43 = [this + 24]
  ret t.43

func Tree_GetKey(this)
  t.44 = [this + 16]
  ret t.44

func Tree_SetKey(this v_key)
  [this + 16] = v_key
  ret 1

func Tree_GetHas_Right(this)
  t.45 = [this + 8]
  ret t.45

func Tree_GetHas_Left(this)
  t.46 = [this + 12]
  ret t.46

func Tree_SetHas_Left(this val)
  [this + 12] = val
  ret 1

func Tree_SetHas_Right(this val)
  [this + 8] = val
  ret 1

func Tree_Compare(this num1 num2)
  ntb = 0
  t.47 = Add(num2 1)
  nti = t.47
  t.48 = LtS(num1 num2)
  if0 t.48 goto :l.0
    ntb = 0
    goto :l.1
  l.0:
    t.49 = LtS(num1 nti)
    t.50 = 0
    ok = Eq(0 t.49)
    if ok goto :l.4
    t.50 = 0
    goto :l.5
    l.4:
    t.50 = 1
    l.5:
    if0 t.50 goto :l.2
      ntb = 0
      goto :l.3
    l.2:
      ntb = 1
    l.3:
  l.1:
  ret ntb

func Tree_Insert(this v_key)
  t.51 = HeapAllocZ(28)
  [t.51] = :Tree
  new_node = t.51
  vt = [new_node]
  vt = [vt]
  f = [vt + 8]
  t.53 = call f(new_node v_key )
  ntb = t.53
  current_node = this
  cont = 1
  l.6:
    if0 cont goto :l.7
    vt = [current_node]
    vt = [vt]
    f = [vt + 40]
    t.55 = call f(current_node)
    key_aux = t.55
    t.56 = LtS(v_key key_aux)
    if0 t.56 goto :l.8
      vt = [current_node]
      vt = [vt]
      f = [vt + 36]
      t.58 = call f(current_node)
      if0 t.58 goto :l.10
        vt = [current_node]
        vt = [vt]
        f = [vt + 64]
        t.60 = call f(current_node)
        current_node = t.60
        goto :l.11
      l.10:
        cont = 0
        vt = [current_node]
        vt = [vt]
        f = [vt + 44]
        t.62 = call f(current_node 1 )
        ntb = t.62
        vt = [current_node]
        vt = [vt]
        f = [vt + 56]
        t.64 = call f(current_node new_node )
        ntb = t.64
      l.11:
      goto :l.9
    l.8:
      vt = [current_node]
      vt = [vt]
      f = [vt + 0]
      t.66 = call f(current_node)
      if0 t.66 goto :l.12
        vt = [current_node]
        vt = [vt]
        f = [vt + 72]
        t.68 = call f(current_node)
        current_node = t.68
        goto :l.13
      l.12:
        cont = 0
        vt = [current_node]
        vt = [vt]
        f = [vt + 4]
        t.70 = call f(current_node 1 )
        ntb = t.70
        vt = [current_node]
        vt = [vt]
        f = [vt + 76]
        t.72 = call f(current_node new_node )
        ntb = t.72
      l.13:
    l.9:
  goto :l.6
  l.7:
  ret 1

func Tree_Delete(this v_key)
  current_node = this
  parent_node = this
  cont = 1
  found = 0
  is_root = 1
  l.14:
    if0 cont goto :l.15
    vt = [current_node]
    vt = [vt]
    f = [vt + 40]
    t.74 = call f(current_node)
    key_aux = t.74
    t.75 = LtS(v_key key_aux)
    if0 t.75 goto :l.16
      vt = [current_node]
      vt = [vt]
      f = [vt + 36]
      t.77 = call f(current_node)
      if0 t.77 goto :l.18
        parent_node = current_node
        vt = [current_node]
        vt = [vt]
        f = [vt + 64]
        t.79 = call f(current_node)
        current_node = t.79
        goto :l.19
      l.18:
        cont = 0
      l.19:
      goto :l.17
    l.16:
      t.80 = LtS(key_aux v_key)
      if0 t.80 goto :l.20
        vt = [current_node]
        vt = [vt]
        f = [vt + 0]
        t.82 = call f(current_node)
        if0 t.82 goto :l.22
          parent_node = current_node
          vt = [current_node]
          vt = [vt]
          f = [vt + 72]
          t.84 = call f(current_node)
          current_node = t.84
          goto :l.23
        l.22:
          cont = 0
        l.23:
        goto :l.21
      l.20:
        if0 is_root goto :l.24
          vt = [current_node]
          vt = [vt]
          f = [vt + 0]
          t.86 = call f(current_node)
          t.87 = 0
          ok = Eq(0 t.86)
          if ok goto :l.28
          t.87 = 0
          goto :l.29
          l.28:
          t.87 = 1
          l.29:
          vt = [current_node]
          vt = [vt]
          f = [vt + 36]
          t.89 = call f(current_node)
          t.90 = 0
          ok = Eq(0 t.89)
          if ok goto :l.30
          t.90 = 0
          goto :l.31
          l.30:
          t.90 = 1
          l.31:
          t.91 = Eq(1 t.87)
          t.92 = Eq(1 t.90)
          t.93 = Eq(t.91 t.92)
          if0 t.93 goto :l.26
            ntb = 1
            goto :l.27
          l.26:
            t.96 = [this]
            t.96 = [t.96]
            t.96 = [t.96 + 60]
            t.95 = call t.96(this parent_node current_node )
            ntb = t.95
          l.27:
          goto :l.25
        l.24:
          t.99 = [this]
          t.99 = [t.99]
          t.99 = [t.99 + 60]
          t.98 = call t.99(this parent_node current_node )
          ntb = t.98
        l.25:
        found = 1
        cont = 0
      l.21:
    l.17:
    is_root = 0
  goto :l.14
  l.15:
  ret found

func Tree_Remove(this p_node c_node)
  vt = [c_node]
  vt = [vt]
  f = [vt + 36]
  t.101 = call f(c_node)
  if0 t.101 goto :l.32
    t.104 = [this]
    t.104 = [t.104]
    t.104 = [t.104 + 24]
    t.103 = call t.104(this p_node c_node )
    ntb = t.103
    goto :l.33
  l.32:
    vt = [c_node]
    vt = [vt]
    f = [vt + 0]
    t.106 = call f(c_node)
    if0 t.106 goto :l.34
      t.109 = [this]
      t.109 = [t.109]
      t.109 = [t.109 + 52]
      t.108 = call t.109(this p_node c_node )
      ntb = t.108
      goto :l.35
    l.34:
      vt = [c_node]
      vt = [vt]
      f = [vt + 40]
      t.111 = call f(c_node)
      auxkey1 = t.111
      vt = [p_node]
      vt = [vt]
      f = [vt + 64]
      t.113 = call f(p_node)
      vt = [t.113]
      vt = [vt]
      f = [vt + 40]
      t.115 = call f(t.113)
      auxkey2 = t.115
      t.118 = [this]
      t.118 = [t.118]
      t.118 = [t.118 + 16]
      t.117 = call t.118(this auxkey1 auxkey2 )
      if0 t.117 goto :l.36
        t.121 = [this + 4]
        vt = [p_node]
        vt = [vt]
        f = [vt + 56]
        t.120 = call f(p_node t.121 )
        ntb = t.120
        vt = [p_node]
        vt = [vt]
        f = [vt + 44]
        t.123 = call f(p_node 0 )
        ntb = t.123
        goto :l.37
      l.36:
        t.126 = [this + 4]
        vt = [p_node]
        vt = [vt]
        f = [vt + 76]
        t.125 = call f(p_node t.126 )
        ntb = t.125
        vt = [p_node]
        vt = [vt]
        f = [vt + 4]
        t.128 = call f(p_node 0 )
        ntb = t.128
      l.37:
    l.35:
  l.33:
  ret 1

func Tree_RemoveRight(this p_node c_node)
  l.38:
    vt = [c_node]
    vt = [vt]
    f = [vt + 0]
    t.130 = call f(c_node)
    if0 t.130 goto :l.39
    vt = [c_node]
    vt = [vt]
    f = [vt + 72]
    t.132 = call f(c_node)
    vt = [t.132]
    vt = [vt]
    f = [vt + 40]
    t.134 = call f(t.132)
    vt = [c_node]
    vt = [vt]
    f = [vt + 32]
    t.136 = call f(c_node t.134 )
    ntb = t.136
    p_node = c_node
    vt = [c_node]
    vt = [vt]
    f = [vt + 72]
    t.138 = call f(c_node)
    c_node = t.138
  goto :l.38
  l.39:
  t.141 = [this + 4]
  vt = [p_node]
  vt = [vt]
  f = [vt + 76]
  t.140 = call f(p_node t.141 )
  ntb = t.140
  vt = [p_node]
  vt = [vt]
  f = [vt + 4]
  t.143 = call f(p_node 0 )
  ntb = t.143
  ret 1

func Tree_RemoveLeft(this p_node c_node)
  l.40:
    vt = [c_node]
    vt = [vt]
    f = [vt + 36]
    t.145 = call f(c_node)
    if0 t.145 goto :l.41
    vt = [c_node]
    vt = [vt]
    f = [vt + 64]
    t.147 = call f(c_node)
    vt = [t.147]
    vt = [vt]
    f = [vt + 40]
    t.149 = call f(t.147)
    vt = [c_node]
    vt = [vt]
    f = [vt + 32]
    t.151 = call f(c_node t.149 )
    ntb = t.151
    p_node = c_node
    vt = [c_node]
    vt = [vt]
    f = [vt + 64]
    t.153 = call f(c_node)
    c_node = t.153
  goto :l.40
  l.41:
  t.156 = [this + 4]
  vt = [p_node]
  vt = [vt]
  f = [vt + 56]
  t.155 = call f(p_node t.156 )
  ntb = t.155
  vt = [p_node]
  vt = [vt]
  f = [vt + 44]
  t.158 = call f(p_node 0 )
  ntb = t.158
  ret 1

func Tree_Search(this v_key)
  current_node = this
  cont = 1
  ifound = 0
  l.42:
    if0 cont goto :l.43
    vt = [current_node]
    vt = [vt]
    f = [vt + 40]
    t.160 = call f(current_node)
    key_aux = t.160
    t.161 = LtS(v_key key_aux)
    if0 t.161 goto :l.44
      vt = [current_node]
      vt = [vt]
      f = [vt + 36]
      t.163 = call f(current_node)
      if0 t.163 goto :l.46
        vt = [current_node]
        vt = [vt]
        f = [vt + 64]
        t.165 = call f(current_node)
        current_node = t.165
        goto :l.47
      l.46:
        cont = 0
      l.47:
      goto :l.45
    l.44:
      t.166 = LtS(key_aux v_key)
      if0 t.166 goto :l.48
        vt = [current_node]
        vt = [vt]
        f = [vt + 0]
        t.168 = call f(current_node)
        if0 t.168 goto :l.50
          vt = [current_node]
          vt = [vt]
          f = [vt + 72]
          t.170 = call f(current_node)
          current_node = t.170
          goto :l.51
        l.50:
          cont = 0
        l.51:
        goto :l.49
      l.48:
        ifound = 1
        cont = 0
      l.49:
    l.45:
  goto :l.42
  l.43:
  ret ifound

func Tree_Print(this)
  current_node = this
  t.173 = [this]
  t.173 = [t.173]
  t.173 = [t.173 + 12]
  t.172 = call t.173(this current_node )
  ntb = t.172
  ret 1

func Tree_RecPrint(this node)
  vt = [node]
  vt = [vt]
  f = [vt + 36]
  t.175 = call f(node)
  if0 t.175 goto :l.52
    vt = [node]
    vt = [vt]
    f = [vt + 64]
    t.177 = call f(node)
    t.180 = [this]
    t.180 = [t.180]
    t.180 = [t.180 + 12]
    t.179 = call t.180(this t.177 )
    ntb = t.179
    goto :l.53
  l.52:
    ntb = 1
  l.53:
  vt = [node]
  vt = [vt]
  f = [vt + 40]
  t.182 = call f(node)
  PrintIntS(t.182)
  vt = [node]
  vt = [vt]
  f = [vt + 0]
  t.184 = call f(node)
  if0 t.184 goto :l.54
    vt = [node]
    vt = [vt]
    f = [vt + 72]
    t.186 = call f(node)
    t.189 = [this]
    t.189 = [t.189]
    t.189 = [t.189 + 12]
    t.188 = call t.189(this t.186 )
    ntb = t.188
    goto :l.55
  l.54:
    ntb = 1
  l.55:
  ret 1


]&gt;
	at org.junit.Assert.assertEquals(Assert.java:115)
	at org.junit.Assert.assertEquals(Assert.java:144)
	at vapor_code_gen.J2VTest.binaryTree(J2VTest.java:48)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.runTestClass(JUnitTestClassExecutor.java:110)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:58)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:38)
	at org.gradle.api.internal.tasks.testing.junit.AbstractJUnitTestClassProcessor.processTestClass(AbstractJUnitTestClassProcessor.java:62)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94)
	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:118)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:412)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)
	at java.base/java.lang.Thread.run(Thread.java:844)
</pre>
</span>
</div>
</div>
<div id="tab1" class="tab">
<h2>Tests</h2>
<table>
<thead>
<tr>
<th>Test</th>
<th>Duration</th>
<th>Result</th>
</tr>
</thead>
<tr>
<td class="failures">binaryTree</td>
<td class="failures">0.117s</td>
<td class="failures">failed</td>
</tr>
</table>
</div>
</div>
<div id="footer">
<p>
<div>
<label class="hidden" id="label-for-line-wrapping-toggle" for="line-wrapping-toggle">Wrap lines
<input id="line-wrapping-toggle" type="checkbox" autocomplete="off"/>
</label>
</div>Generated by 
<a href="http://www.gradle.org">Gradle 5.6.4</a> at Jul 28, 2020, 1:23:50 PM</p>
</div>
</div>
</body>
</html>
